---
title: "Estudio_Mod_1"
author: "Fernando Alvarado"
date: "2025-04-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Resumen de codigo R, de mi diplomado de ciecia de datos 



## ğŸ“¦ base (Funciones bÃ¡sicas de R para secuencias, matrices y estructuras)

- `seq()`: Genera secuencias numÃ©ricas. Por ejemplo, `seq(1, 5, 0.5)` crea una secuencia de 1 a 5 en incrementos de 0.5.
- `rep()`: Repite valores. `rep(c(1,3,8), times = 7)` repite todo el vector 7 veces.
- `sequence()`: Devuelve una secuencia continua basada en un vector de enteros. `sequence(c(10,5))` genera una secuencia del 1 al 10 y luego del 1 al 5.
- `dim() <-`: Asigna dimensiones a un vector para convertirlo en matriz. `dim(a) <- c(2,5)` convierte un vector en una matriz de 2 filas y 5 columnas.
- `class()`: Muestra la clase (tipo de objeto) de un elemento. Ãštil para verificar si es vector, matriz, lista, etc.
- `str()`: Muestra la estructura de un objeto, muy Ãºtil para inspecciÃ³n rÃ¡pida.
- `matrix()`: Crea una matriz. `matrix(data = c(...), nr = x, nc = y)` genera una matriz con datos, filas (`nr`) y columnas (`nc`).
- `a[i,j] <- valor`: Asigna un valor a una posiciÃ³n especÃ­fica de una matriz.



## ğŸ“¦ utils/base (GestiÃ³n de paquetes)

- `install.packages("nombre")`: Instala un paquete desde CRAN. Solo se necesita hacer una vez por instalaciÃ³n.
- `library(nombre)`: Carga el paquete para poder usar sus funciones en la sesiÃ³n actual.




## ğŸ“¦ base (ManipulaciÃ³n de matrices, tipos y coerciones)

- `as.numeric(x)`: Convierte un valor a numÃ©rico. Si no se puede (como `"Hola"`), regresa `NA`.
- `as.character(x)`: Convierte valores numÃ©ricos a texto (string).
- `matrix(data, nrow, ncol)`: Crea una matriz con los datos, especificando filas y columnas.
- `a[i, j]`: Accede o modifica la entrada de una matriz en la fila `i` y columna `j`.
- `%*%`: Realiza multiplicaciÃ³n matricial (Ã¡lgebra lineal). No confundir con `*` que es multiplicaciÃ³n entrada por entrada.
- `+` entre matrices: Suma elemento a elemento (si tienen la misma dimensiÃ³n).




## ğŸ“¦ base (Operaciones adicionales con matrices y listas)

- `solve(x)`: Calcula la inversa de una matriz (si existe). Por ejemplo, `solve(mat2)` retorna la matriz inversa de `mat2`.
- `rbind(x, y)`: Une matrices por renglones (una encima de la otra).
- `cbind(x, y)`: Une matrices por columnas (una al lado de la otra).
- `list(...)`: Crea una lista, que permite contener objetos de distintos tipos (nÃºmeros, textos, vectores, matrices, etc.).
- `length(x)`: Devuelve la cantidad de elementos/componentes de una lista.
- `x[[i]]`: Accede al **objeto contenido** en la componente `i` de una lista.
- `x[i]`: Extrae la **sublista** con la componente `i`, mantiene estructura de lista.
- `x$nombre`: Accede directamente al objeto en la componente nombrada `"nombre"` de la lista.
- `c(x, y)`: Concatena listas (o vectores).
- `unlist(x)`: Convierte una lista a un vector plano.




## ğŸ“¦ purrr (ProgramaciÃ³n funcional con listas y vectores)

- `map_dbl(.x, .f)`: Aplica una funciÃ³n a cada elemento de una lista o vector, devolviendo un vector numÃ©rico. Es Ãºtil cuando se espera un resultado `double` y se quiere evitar listas.
- `compose(...)`: Crea funciones compuestas, ejecutando de derecha a izquierda. Por ejemplo, `compose(sqrt, abs)` aplica primero `abs()` y luego `sqrt()`.




## ğŸ“¦ base (Control de flujo y generaciÃ³n de secuencias)

- `seq_along(x)`: Genera una secuencia desde 1 hasta la longitud de `x`. Ãštil en `for` cuando no se conoce la longitud exacta del objeto.
- `seq_len(n)`: Crea una secuencia del 1 al nÃºmero `n`. Se usa para iterar conociendo la cantidad de elementos.
- `while(cond) { ... }`: Ejecuta un bloque de cÃ³digo mientras la condiciÃ³n `cond` sea verdadera.
- `next`: Salta a la siguiente iteraciÃ³n dentro de un bucle.
- `break`: Rompe la ejecuciÃ³n del bucle actual.

---

## ğŸ“¦ purrr (IteraciÃ³n funcional avanzada)

- `map(.x, .f)`: Aplica una funciÃ³n `.f` a cada elemento de `.x`, devolviendo una lista. Ãštil para aplicar funciones personalizadas o integradas como `summary`, `toupper`, etc.
- `map_dbl(.x, .f)`: Igual que `map()`, pero devuelve un vector numÃ©rico (`double`) en lugar de lista.
- `compose(f1, f2, ...)`: Crea una funciÃ³n compuesta que aplica primero la Ãºltima (`fN`) y termina con la primera (`f1`). Ideal para encadenar transformaciones sin definir funciones intermedias.



```{r}
## Ejemplo de `map()` con purrr

# Cargamos purrr
library(purrr)

# Vector de nombres
nombres <- c("juan", "maria", "pedro")

# Aplicamos la funciÃ³n toupper a cada elemento del vector
resultado <- map(nombres, toupper)

# Mostramos resultado
resultado

```



# LibrerÃ­as para visualizaciÃ³n

+ [R Base](https://rstudio-pubs-static.s3.amazonaws.com/7953_4e3efd5b9415444ca065b1167862c349.html)
+ [ggplot2](https://ggplot2.tidyverse.org/)
+ [plotly](https://plot.ly/r/)
+ [lattice](http://lattice.r-forge.r-project.org/Vignettes/src/lattice-intro/lattice-intro.pdf)
+ [rCharts](https://ramnathv.github.io/rCharts/)
+ [corrplot](https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html)
+ [rbokeh](http://hafen.github.io/rbokeh/index.html)
+ [leaflet](https://rstudio.github.io/leaflet/)
+ [highcharter](http://jkunst.com/highcharter/)
+ [ggiraph](https://davidgohel.github.io/ggiraph/index.html)
+ [gganimate](https://github.com/thomasp85/gganimate)
+ [gghighlight](https://cran.r-project.org/web/packages/gghighlight/vignettes/gghighlight.html)
+ [dygraphs](https://rstudio.github.io/dygraphs/index.html)
+ [trelliscopejs](https://github.com/hafen/trelliscopejs)
+ [esquisse](https://github.com/dreamRs/esquisse)

# La interacciÃ³n siempre vende

+ [Shiny](https://shiny.rstudio.com/gallery/)
+ [Shiny](https://shiny.rstudio.com/gallery/see-more.html)
+ [Shiny dashboards](https://rstudio.github.io/shinydashboard/index.html)
+ [Flexdashboard](https://rmarkdown.rstudio.com/flexdashboard/examples.html)



## ğŸ“¦ ggplot2 (VisualizaciÃ³n de datos)

- Crea grÃ¡ficos personalizados y profesionales de forma declarativa usando `ggplot() + geom_*()`.

## ğŸ“¦ readr (Lectura eficiente de datos)

- Permite importar archivos `.csv`, `.tsv`, y mÃ¡s con funciones como `read_csv()` (no usada aÃºn en el cÃ³digo).

## ğŸ“¦ dplyr (ManipulaciÃ³n de datos)

- Facilita tareas como filtrar (`filter()`), seleccionar (`select()`), mutar (`mutate()`), agrupar (`group_by()`), resumir (`summarise()`), entre muchas otras.

## ğŸ“¦ palmerpenguins (Conjunto de datos)

- Proporciona datos sobre especies de pingÃ¼inos en la AntÃ¡rtida. Ideal para ejemplos de anÃ¡lisis y visualizaciÃ³n.




```{r}
## Ejemplo sencillo con palmerpenguins

library(ggplot2)
library(dplyr)
library(palmerpenguins)

# Usamos el dataset 'penguins' incluido en el paquete
datos <- penguins |> filter(!is.na(body_mass_g), !is.na(flipper_length_mm))

# Creamos una grÃ¡fica de dispersiÃ³n bÃ¡sica
ggplot(datos, aes(x = body_mass_g, y = flipper_length_mm)) +
  geom_point(color = "steelblue") +
  labs(title = "RelaciÃ³n entre masa corporal y longitud del ala",
       x = "Masa corporal (g)",
       y = "Longitud del ala (mm)") +
  theme_minimal()

```
## ğŸ“¦ palmerpenguins â€” Ejemplo con `penguins`

- Se filtran los datos para remover valores `NA` en `body_mass_g` y `flipper_length_mm`.
- Se hace una grÃ¡fica con `ggplot2` mostrando la relaciÃ³n entre masa corporal y longitud del ala de los pingÃ¼inos.
- `geom_point()` genera una dispersiÃ³n con color azul, y se aplican etiquetas y tema minimalista.




## ğŸ“¦ base (CreaciÃ³n y manipulaciÃ³n de dataframes)

- `data.frame(...)`: Crea un dataframe con columnas de distintos tipos (nÃºmeros, texto, etc.).
- `str(x)`: Muestra la estructura de un dataframe, Ãºtil para revisar tipos de datos.
- `dim(x)`, `nrow(x)`, `ncol(x)`: Devuelven dimensiones, nÃºmero de filas y columnas respectivamente.
- `names(x)`: Muestra o modifica los nombres de las columnas.
- `summary(x)`: Da un resumen estadÃ­stico general del contenido del dataframe.
- `x[i, j]`, `x["col"]`, `x[["col"]]`, `x$col`: Formas de acceder a columnas o celdas especÃ­ficas.
- `cbind(df, nueva_col)`: Agrega columnas a un dataframe existente.
- `rbind(df, nuevo_row)`: Agrega filas a un dataframe.

## ğŸ“¦ base (MÃ¡s formas de crear y convertir dataframes)

- `x$col <- ...`: Crea y asigna una nueva columna en un dataframe usando el operador `$`.
- `as.data.frame(x)`: Convierte un objeto (como una matriz) en un dataframe.

---

## ğŸ“¦ ggplot2movies (Dataset de pelÃ­culas)

- `movies`: Dataset incluido con informaciÃ³n de mÃ¡s de 58 mil pelÃ­culas (tÃ­tulo, aÃ±o, gÃ©nero, calificaciÃ³n, etc.).
- `head(x, n)`: Muestra los primeros `n` renglones de un dataframe.
- `tail(x, n)`: Muestra los Ãºltimos `n` renglones de un dataframe.
- `help(movies)`: Muestra la documentaciÃ³n del dataset si estÃ¡ disponible.

---

## ğŸ“¦ dplyr (ManipulaciÃ³n de renglones con pipes)

- `slice(df, i:j)`: Extrae un subconjunto de renglones del dataframe desde `i` hasta `j` usando el pipe `%>%`.



## ğŸ“¦ dplyr â€” Verbos esenciales para manipular dataframes

La librerÃ­a `dplyr` permite manipular dataframes de manera intuitiva, legible y eficiente. Es especialmente Ãºtil en anÃ¡lisis de datos donde se trabaja mucho con tablas.

A continuaciÃ³n se explican sus cinco verbos fundamentales:

---

### ğŸ”¹ 1. `arrange()`: Ordenar filas

**Â¿QuÃ© hace?**  
Ordena los renglones de un dataframe en funciÃ³n de una o varias columnas.

**Â¿CuÃ¡ndo se usa?**  
Cuando queremos ver los datos ordenados por algÃºn criterio, ya sea numÃ©rico (por ejemplo, de menor a mayor edad) o alfabÃ©tico (por ejemplo, ordenar por nombre).

**Â¿Para quÃ© se usa?**  
Para facilitar la exploraciÃ³n, para obtener valores extremos (los mÃ¡s altos o bajos), o simplemente para ordenar resultados antes de visualizarlos.

**Ejemplos:**


```{r}
# Ordenar por la columna length de menor a mayor
library(palmerpenguins)
datos <- penguins

datos %>% arrange(datos$flipper_length_mm ) |> head()

# Ordenar alfabÃ©ticamente por tÃ­tulo (columna de tipo texto)
datos %>% arrange(datos$species) |> head()

# Ordenar de mayor a menor por la columna length
datos %>% arrange(desc(datos$flipper_length_mm)) %>% head()
```


### ParÃ©ntesis

+ Como insertar un renglÃ³n en una posiciÃ³n que yo quiero

```{r}
df <- data.frame(team=c('A', 'A', 'A', 'A', 'B', 'B', 'B', 'B'),
                 points=c(99, 68, 86, 88, 95, 74, 78, 93),
                 assists=c(22, 28, 31, 35, 34, 45, 28, 31),
                 rebounds=c(30, 28, 24, 24, 30, 36, 30, 29))

df
```
+ Primera forma: Horrible (R base)

```{r}
nuevo_vector <- c("D", 1, 4, 6, 8)
nuevo_vector
```
+ Ocuperemos la funciÃ³n rbind()

```{r}
posicion_favorita <- 3
```

```{r}
rbind(df[1:(posicion_favorita-1),], # todos los renglones antes de la posiciÃ³n
      nuevo_vector, # nuevo renglon
      df[-(1:(posicion_favorita-1)),]) # resto de los renglones
```

+ Forma terrible!!! TendrÃ­a ahora que arreglar el tema de los Ã­ndices de los renglones

+ Forma limpia... Con una funciÃ³n de la librerÃ­a {dplyr}

```{r}
df %>% dplyr::add_row(team='C', points=90, assists=40, rebounds=20, .before=posicion_favorita)
```


## ğŸ“¦ dplyr â€” Verbo `select()`: seleccionar columnas

### ğŸ”¹ 2. `select()`: Elegir columnas especÃ­ficas

**Â¿QuÃ© hace?**  
Permite seleccionar columnas de un dataframe por nombre, posiciÃ³n o patrÃ³n.

**Â¿CuÃ¡ndo se usa?**  
Cuando queremos trabajar solo con ciertas variables, eliminar columnas innecesarias, o reorganizar el orden de las columnas.

**Â¿Para quÃ© se usa?**  
- Limpiar y reducir la cantidad de informaciÃ³n para enfocarnos solo en lo necesario.
- Organizar columnas para facilitar la lectura o el anÃ¡lisis posterior.

---

### âœ… Formas comunes de usar `select()`:


```{r}



# SelecciÃ³n por nombre explÃ­cito
iris %>% select(Species, Sepal.Length, Sepal.Width) |> head()

# SelecciÃ³n por rango de columnas
iris %>% select(Sepal.Length:Petal.Length) |> head()

# Eliminar columnas con el operador negativo
iris %>% select(-Species) |> head()
iris %>% select(-Sepal.Width, -Petal.Length) |> head()
iris %>% select(-(Sepal.Width:Petal.Length)) |> head()

```

```{r}

library(dplyr)
datos <- iris
# columnas que empiezan con "Sepal"
datos %>% select(starts_with("Sepal")) |> head()

# columnas que terminan con "Width"
datos %>% select(ends_with("Width")) |> head()

# columnas que contienen la letra "e"
datos %>% select(contains("e")) |> head()

# âš ï¸ num_range() requiere columnas como r1, r2, r3, etc.
# Este ejemplo no aplica a iris, pero se muestra como referencia:
# select(num_range("r", 2:5))

# Ãºltima columna del dataframe
datos %>% select(last_col()) |> head()


# Ver valores Ãºnicos de la columna Species
datos %>% select(Species) %>% unique() |> head()

# Ordenar los valores Ãºnicos (aunque en iris ya estÃ¡n ordenados)
datos %>% select(Species) %>% unique() %>% arrange(Species) |> head()

# Mostrar las 10 observaciones con los valores mÃ¡s altos de Sepal.Length
datos %>% top_n(10, wt = Sepal.Length) |> head()


```




### ğŸ“¦ dplyr â€” Verbo `filter()`: filtrar filas


 filter(condiciÃ³n): Selecciona solo las filas que cumplen cierta condiciÃ³n lÃ³gica.
 
 Se puede combinar con operadores lÃ³gicos como:
 
+   &    â†’ y lÃ³gico
+   |    â†’ o lÃ³gico
+   ==   â†’ igual
+   !=   â†’ diferente
+   <    â†’ menor que
+   <=   â†’ menor o igual
+   >    â†’ mayor que
+   >=   â†’ mayor o igual
+   %in% â†’ pertenece a un conjunto de valores

 Importante: filter() devuelve un nuevo dataframe con solo las filas que cumplen las condiciones.


```{r}

library(dplyr)
datos <- iris
# Filtrar todas las flores cuya especie sea "setosa"
datos %>% filter(Species == "setosa") |> head()

# Filtrar flores con largo de pÃ©talo mayor a 5
datos %>% filter(Petal.Length > 5) |> head()

# CondiciÃ³n combinada: Species = virginica Y ancho del sÃ©palo > 3
datos %>% filter(Species == "virginica" & Sepal.Width > 3) |> head()

# Usando %in% para mÃºltiples valores
datos %>% filter(Species %in% c("versicolor", "virginica")) |> head()


```

```{r}

library(ggplot2)

datos %>%
  filter(Species %in% c("versicolor", "virginica")) %>%
  ggplot(aes(x = Petal.Length, y = Petal.Width, color = Species)) +
  geom_point() +
  labs(title = "ComparaciÃ³n entre versicolor y virginica") +
  theme_minimal()


```

## ğŸ“¦ dplyr â€” Verbo `group_by()`: agrupar datos

 group_by(columna): Agrupa el dataframe segÃºn una o varias columnas.
 
  Esto permite aplicar operaciones resumen como media, suma, conteo, etc. por grupo.
  
  Casi siempre se usa junto con summarise().


```{r}
# Promedio de largo de pÃ©talo por especie
datos %>%
  group_by(Species) %>%
  summarise(promedio_petal_length = mean(Petal.Length))

# Promedio y desviaciÃ³n estÃ¡ndar del ancho del sÃ©palo por especie
datos %>%
  group_by(Species) %>%
  summarise(
    promedio_sepal_width = mean(Sepal.Width),
    desviacion_sepal_width = sd(Sepal.Width)
  )

```

+ summarise() reduce cada grupo a una fila.

+ n() dentro de summarise() cuenta cuÃ¡ntas filas hay por grupo.

+ Se puede agrupar por mÃ¡s de una variable si se desea, por ejemplo:

+ group_by(Species, otra_variable)




## ğŸ“¦ dplyr â€” Verbo `summarise()`: resumir datos

+ summarise(): Crea una nueva tabla con valores agregados (resumen) para cada grupo.

+ Debe usarse despuÃ©s de group_by() para calcular estadÃ­sticas por grupo.

+ Devuelve una fila por grupo con las mÃ©tricas especificadas (promedio, suma, conteo, etc.)


```{r}
# Promedio del largo de pÃ©talo por especie
datos %>%
  group_by(Species) %>%
  summarise(promedio_petal_length = mean(Petal.Length))
```


```{r}
# CÃ¡lculo de promedio y mediana por especie
datos %>%
  group_by(Species) %>%
  summarise(
    media_largo_sepalo = mean(Sepal.Length),
    mediana_largo_sepalo = median(Sepal.Length)
  )
```

```{r}
# Contar cuÃ¡ntas observaciones hay por especie
datos %>%
  group_by(Species) %>%
  summarise(total = n())
```
#### Notas

+ summarise() colapsa el dataframe a una fila por grupo.

+ Puedes usar cualquier funciÃ³n resumen: mean(), sd(), sum(), min(), max(), n(), etc.

+ Si no usas group_by(), summarise() calcula una sola fila para todo el dataframe.


## ğŸ“¦ dplyr â€” Verbo `mutate()`: crear nuevas columnas


+ mutate(): Crea nuevas columnas o modifica columnas existentes en un dataframe.

 Las nuevas columnas pueden ser creadas a partir de operaciones con otras columnas existentes.
 
 El dataframe conserva todas las columnas originales, con las nuevas agregadas al final (a menos que se indique lo contrario).


```{r}
# Crear una columna llamada "doble_petal_length"
datos %>%
  mutate(doble_petal_length = Petal.Length * 2) |> head(n=10)

```

```{r}
# Crear columnas con Ã¡rea del pÃ©talo y largo total (sÃ©palo + pÃ©talo)
datos %>%
  mutate(
    area_petal = Petal.Length * Petal.Width,
    total_length = Petal.Length + Sepal.Length
  ) |> head(n=10)

```

+ mutate() es muy Ãºtil para preparar variables antes de modelar o graficar.

+ Se puede usar en combinaciÃ³n con funciones condicionales, matemÃ¡ticas, lÃ³gicas, etc.

+ TambiÃ©n puedes usar funciones como if_else(), case_when(), round(), as.character(), etc. dentro de mutate().


## ğŸ“¦ dplyr â€” Verbos de uniÃ³n: `left_join()`, `inner_join()`, `right_join()`, `full_join()`

### ğŸ“ Resumen

- Los *joins* permiten **unir dos tablas** por una o varias columnas comunes, como en SQL.
- Muy Ãºtil cuando necesitas **agregar columnas complementarias** desde otra tabla.

### ğŸ”‘ Â¿CÃ³mo funcionan?

- left_join(x, y, by = ...): Une las filas de `x` con las coincidencias de `y`. Si no hay coincidencia, rellena con `NA`.
- inner_join(x, y, by = ...): Devuelve solo las filas que tienen coincidencias en ambas tablas.
- right_join(x, y, by = ...): Igual que `left_join()`, pero priorizando las filas de `y`.
- full_join(x, y, by = ...): Devuelve todas las filas de ambas tablas, rellenando con `NA` cuando no haya coincidencia.

### ğŸ’¡ Extra

- Si los nombres de las columnas clave **son diferentes**, se usa:


  left_join(tablaB, by = c("colA" = "colB")



## ğŸ“¦ patchwork â€” Combinar mÃºltiples grÃ¡ficas ggplot2

### ğŸ“ Resumen

- `{patchwork}` facilita la **composiciÃ³n de varias grÃ¡ficas `ggplot2`** en una sola ventana.
- Se usa con los **operadores matemÃ¡ticos**:
  - `+`: para poner grÃ¡ficas lado a lado (horizontales).
  - `/`: para apilarlas verticalmente.
  - `|`: tambiÃ©n sirve para ponerlas lado a lado.
  - Combinaciones como `(g1 | g2) / g3` permiten diseÃ±os personalizados.

### ğŸ’¡ Ventajas

- Evita tener que usar `gridExtra` o `cowplot`.
- Sintaxis simple e intuitiva.
- Se puede usar con cualquier objeto creado con `ggplot()`.

---

### ğŸ” Ejemplo en R (con `palmerpenguins`)

```{r message=FALSE, warning=FALSE}
library(ggplot2)
library(patchwork)
library(dplyr)
library(palmerpenguins)

datos <- penguins %>% filter(!is.na(body_mass_g), !is.na(flipper_length_mm))

graf1 <- datos %>% 
  ggplot(aes(x = body_mass_g, y = flipper_length_mm)) +
  geom_point(color = "red", shape = 18, size = 2) +
  labs(x = "Masa corporal (g)", y = "Longitud del ala (mm)") +
  theme_light()

graf2 <- datos %>% 
  ggplot(aes(x = body_mass_g, y = flipper_length_mm)) +
  geom_point(color = "purple", shape = 18, size = 2) +
  theme_gray()

# Lado a lado
graf1 + graf2
```

```{r}
# Una arriba de la otra
graf1 / graf2
```

```{r}
# Tercer grÃ¡fica y composiciÃ³n combinada
graf3 <- datos %>%
  ggplot(aes(x = body_mass_g, y = flipper_length_mm)) +
  geom_line(color = "orange") +
  labs(x = "Masa corporal (g)", y = "Longitud del ala (mm)") +
  theme_minimal()

# ComposiciÃ³n personalizada
(graf1 | graf2) / graf3

```


## ğŸ“¦ dplyr â€” Funciones condicionales: `case_when()` y `case_match()`

### ğŸ“ Resumen

- `case_when()` y `case_match()` son funciones de `{dplyr}` usadas para **asignar valores categÃ³ricos** o transformar variables con condiciones mÃºltiples.
- Simulan el comportamiento de `if / else if / else`, o incluso `switch`, pero con sintaxis mÃ¡s legible.
- Son muy Ãºtiles para convertir variables numÃ©ricas en etiquetas ("1" â†’ "oro") o crear clasificaciones personalizadas.

---

### ğŸ”¹ case_when()

- Sintaxis basada en condiciones lÃ³gicas:  
  `condiciÃ³n ~ valor`
- EvalÃºa de arriba hacia abajo, **la primera condiciÃ³n que se cumple se aplica**.
- Si no se cumple ninguna condiciÃ³n, devuelve `NA`, a menos que se use `.default`.

```{r}

medallas <- c(1,1,1,3,3,3,3,1,2,NA,NA,2,2,1,4)
# 1 = oro
# 2 = plata
# 3 = bronce


dplyr::case_when(
  medallas == 1 ~ "oro",
  medallas == 2 ~ "plata",
  medallas == 3 ~ "bronce"
)



```











































































